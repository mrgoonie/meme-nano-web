# **Product Development Requirements (PDR) \- MemeNano: AI First Meme Generator**

Version: 1.0 (MVP)
Date: 09/22/2025
Product Name: MemeNano \- AI First Meme Generator

## **1\. Product Overview & Vision**

### **1.1. Introduction**

MemeNano is an AI-first web application for creating memes. Instead of requiring users to search for templates and think up captions themselves, MemeNano simplifies the entire process: users simply input an idea (prompt), and AI automatically generates multiple humorous and relevant memes.

### **1.2. Problem Statement**

Creating a quality meme requires:

* **Creativity:** Coming up with funny, contextually appropriate captions.
* **Meme Knowledge:** Knowing and finding the right meme template for your idea.
* **Time & Tools:** Spending time searching and using editing tools to add text to images.

MemeNano solves this problem by automating all these steps, helping users create memes quickly and easily from just a single line describing their idea.

### **1.3. MVP Goals**

* Build and validate the core meme generation flow from input prompt to final image output.
* Allow users to use their own API keys (BYOK \- Bring Your Own Key) to ensure sustainability and reduce operational costs.
* Provide basic features: meme generation, download to device, and sharing to other platforms.
* Create a minimalist, intuitive, and easy-to-use user interface (UI) that adheres to YAGNI, KISS, and DRY principles.

## **2\. Target Users**

* **Social Media Users:** People who frequently use and share memes on platforms like Facebook, Instagram, X (Twitter), Zalo.
* **Content Creators:** Content creators who want to quickly generate memes to increase engagement on their channels.
* **General Users:** Anyone who wants a quick entertainment tool to create memes to share with friends and family without needing image editing skills.

## **3\. Workflow and Features**

### **3.1. Overall Workflow**

1. **Input Prompt:** User opens the application and enters an idea or description for the meme in a text field.
   * *Example: "When you deploy code to production on Friday afternoon"*
2. **Submit Request:** User clicks the "Generate" button. The application displays a processing status.
3. AI Processing (Client-side Logic):
   a. Prompt Analysis & Template Search:
   \- LLM (Gemini 2.5 Flash) receives the prompt from the user via client API call.
   \- LLM analyzes the prompt, extracting key keywords and main context.
   \- LLM automatically generates multiple search queries (keywords) and calls the Imgflip API to find the most suitable meme templates.
   b. Generate Captions:
   \- Based on the original prompt and meme templates found from Imgflip, LLM (Gemini 2.5 Flash) creates multiple sets of humorous and appropriate captions for each template.
   c. Generate Complete Meme Images:
   \- The application sends the meme template from Imgflip along with corresponding captions to the Image Generation API (gemini-2.5-flash-image-preview \- Nano Banana).
   \- This API will "redraw" or edit the meme template, adding captions to the correct positions (usually top and bottom of the image) to create the final meme image.
   \- This process is repeated to generate up to 4 different memes.
4. **Display Results:** The application displays up to 4 generated memes on the results screen.
5. **Interact with Results:** For each meme, users can:
   * **Download:** Download the meme to their device as an image file.
   * **Share:** Use Web Share API or copy link to share the meme.

### **3.2. Detailed Feature Descriptions**

#### **F01: Generate Meme from Prompt**

* **Description:** The core functionality of the application. Users input text describing their idea and AI generates memes.
* **Requirements:**
  * A large, clear text input field on the main screen.
  * A "Generate" button to start the process.
  * Display a loading indicator/animation while waiting for API results so users know the system is processing.

#### **F02: Display Results**

* **Description:** Display memes generated by AI.
* **Requirements:**
  * Display up to 4 memes in a grid or swipeable card carousel.
  * Each meme must display clearly without distortion or pixelation.
  * Below each meme are 2 buttons: "Save" and "Share".

#### **F03: Download Meme**

* **Description:** Allow users to download memes to their device.
* **Requirements:**
  * When clicking the "Download" button, the meme will be downloaded as an image file.
  * Display a brief confirmation message (e.g., "Downloaded successfully\!").

#### **F04: Share Meme**

* **Description:** Allow users to share memes directly from the application.
* **Requirements:**
  * When clicking the "Share" button, the application uses Web Share API (if supported) or displays share options.
  * Users can share memes via social media platforms or copy link.

#### **F05: API Key Settings (BYOK)**

* **Description:** Users need to provide their own Gemini API key to use AI features.
* **Requirements:**
  * Have a separate "Settings" screen.
  * On the Settings screen, have an input field for users to paste their API key.
  * A "Save" button to save the key.
  * The application must securely store the API key in localStorage or sessionStorage with appropriate encryption.
  * Provide a link or brief instructions on how to obtain a Gemini API key.
  * If API key has not been entered or is invalid, the application should display a friendly error message when users try to generate memes.

## **4\. Screen Descriptions**

### **4.1. Home Screen**

* **Purpose:** Starting point where users input their meme idea.
* **UI Components:**
  * **Header:** "MemeNano" title.
  * **Settings Icon:** Gear icon in top right corner, leading to Settings Screen.
  * **Prompt Input Area:** Large, multi-line TextField with placeholder text like "Describe your meme idea here..."
  * **Call-to-Action:** Prominent "Generate" button at the bottom.
* **States:**
  * **Default:** Ready for user input.
  * **Loading:** After clicking "Generate", the button is disabled and a loading spinner (or animation) appears to indicate processing.

### **4.2. Results Screen**

* **Purpose:** Display generated memes.
* **UI Components:**
  * **Header:** "Back" or "Try Another" button to return to Home Screen.
  * **Results Grid/Carousel:** Display 1 to 4 memes as cards.
  * **Meme Card:**
    * Generated meme image.
    * Two buttons below: Save icon and Share icon.
* **States:**
  * **Success:** Display memes.
  * **Failure:** If meme generation encounters an error (e.g., invalid API key, template not found, network error), the screen displays a friendly error message and a retry button. Example: "Oops\! Something went wrong. Please check your API key and try again."

### **4.3. Settings Screen**

* **Purpose:** Allow users to input and save their Gemini API key.
* **UI Components:**
  * **Header:** "Settings" title and "Back" button to return.
  * **API Key Input:** TextField for users to paste their key.
  * **Save Button:** Button to confirm and save the key.
  * **Instructional Text:** Brief paragraph explaining why an API key is needed and link to Google AI Studio where users can create a key.

## **5\. Technical & Non-functional Requirements**

### **5.1. Technology Stack**

* **Framework:** Next.js 15 (App Router) with TypeScript
* **Frontend:** React 19
* **Styling:** TailwindCSS (utility-first CSS framework)
* **State Management:** Zustand (lightweight state management)
* **UI Components:** shadcn/ui (customizable, accessible component library)
* **Backend:** Next.js API Routes (serverless functions)
* **HTTP Client:** Native fetch API (built-in to Next.js)
* **Deployment:** Vercel (full-stack deployment with Edge Functions)
* **External APIs:**
  * **Imgflip API:** For searching and retrieving popular meme templates.
  * **Google Gemini API:**
    * Model gemini-2.5-flash: For prompt analysis and caption generation.
    * Model gemini-2.5-flash-image-preview (Nano Banana): For image editing and adding text to memes.

### **5.2. Architecture & Security**

* **Next.js Architecture:**
  * **Client Components:** Handle user interactions and UI rendering.
  * **Server Components:** For static content and improved performance.
  * **API Routes:** Serverless functions deployed as Vercel Edge Functions.
  * **App Router:** Modern routing with built-in layouts and loading states.

* **API Proxy Pattern:**
  * Frontend (Client Components) never directly calls Gemini API with user's API key.
  * User's Gemini API key is sent from client to Next.js API routes via secure HTTPS request.
  * API routes act as a proxy, making calls to Gemini API with the user's key.
  * API key is never stored on the server; it's only used in-memory during the request lifecycle.
  * This prevents API key exposure in client-side code or network inspection.

* **Security Measures:**
  * All API communications use HTTPS/TLS encryption (enforced by Vercel).
  * API keys are transmitted in request headers (Authorization header), never in URLs.
  * Next.js API routes implement rate limiting to prevent abuse.
  * Input validation and sanitization on both client and server.
  * Built-in CORS protection via Next.js middleware.
  * No logging of sensitive data (API keys, user prompts).
  * Vercel's automatic DDoS protection and WAF.

### **5.3. Non-functional Requirements**

* **Performance:**
  * Time from clicking "Generate" to receiving results should not exceed 15 seconds.
  * Next.js automatic code splitting and optimization.
  * Image optimization using Next.js Image component.
  * Clear loading indicator with progress feedback.
  * Vercel Edge Functions for low-latency API responses.
  * Static generation for landing pages where possible.

* **Error Handling:** Application must gracefully handle error scenarios:
  * No network connection.
  * Invalid or expired API key quota.
  * Imgflip or Gemini API errors.
  * Timeout and retry logic for API calls.
  * User-friendly error messages in plain language.

* **Accessibility:**
  * Comply with WCAG 2.1 AA standards.
  * Keyboard navigation support.
  * Screen reader friendly.
  * Proper ARIA labels and semantic HTML.

* **Responsive Design:**
  * Smooth operation on desktop, tablet, and mobile devices.
  * Mobile-first approach.
  * Touch-friendly interactive elements.

* **Design:**
  * Clean, modern, and minimalist interface.
  * Consistent design language with shadcn/ui components.
  * Dark mode support (optional for MVP).

### **5.4. Development Principles**

* **YAGNI (You Ain't Gonna Need It):** Focus only on features defined in this PDR for the MVP version. Do not add complex features like user accounts, meme history, etc.
* **KISS (Keep It Simple, Stupid):** Keep the code and application architecture as simple as possible. User interface must be intuitive and require no instructions.
* **DRY (Don't Repeat Yourself):** Reuse components and logic wherever possible to avoid code duplication.